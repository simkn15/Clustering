library(transclustr)
library(ggplot2)
library(plyr)
setwd("~/Dropbox/sdu/clustering/datasets")
library(transclustr)
library(ggplot2)
library(plyr)
SD <- 1
CLUSTER_SIZE <- 50
THRESHOLD = 15
table <- read.table("brown.txt", sep = "", skip = 5)
df_table <- as.data.frame(table)
proteins = levels(df_table[,1])
proteins
?levels
?gl
?levels
x <- gl(2,4,8)
x
x <- gl(2,5,8)
x
x <- gl(3,2,8)
x
table <- read.table("brown.txt", sep = "", skip = 5)
df_table <- as.data.frame(table)
proteins = levels(df_table[,1])
df_table[,1]
sim_matrix = matrix(0,nrow = length(proteins), ncol = length(proteins))
sim_matrix
length(proteins)
row.names(sim_matrix) = proteins
colnames(sim_matrix) = proteins
sim_matrix[1,1]
sim_matrix[1,]
sim_matrix[1,1]
sim_matrix["gi3287737"]
sim_matrix["gi3287737",]
sim_matrix["gi3287737","gi627281"]
row.names(sim_matrix) = proteins
col.names(sim_matrix) = proteins
rownames(sim_matrix) = proteins
row.names(sim_matrix) = proteins
colnames(sim_matrix) = proteins
c <- matrix(rexp(200, rate=.1), ncol=20)
c
c <- matrix(rexp(200, rate=.1), ncol=5)
c
c <- matrix(rexp(20, rate=.1), ncol=5)
c
c[2]
c[1]
c[,1]
c[,2]
for(x in 1:(length(proteins)-1)){
# Select all rows containing p1
p1 = proteins[x]
presec = df_table[df_table[,1] == p1 | df_table[,2] == p1, ]
for(y in (x+1):length(proteins)){
p2 = proteins[y]
# We have to check for both directions p1 -> p2 and p2 <- p1. Rule is, to be more conservative, we take the minimum of both values
if(length(presec[presec[,1] == p2, 3])==0 | length(presec[presec[,2] == p2, 3])==0){
#Allright, one value was missing, we take 0 as fallback (since there is no meaningful minimum)
sim_matrix[x,y] = sim_matrix[y,x] = 0
}else{
#Take the minimum of both directions
sim_matrix[x,y] = sim_matrix[y,x] = min(presec[presec[,1] == p2, 3], presec[presec[,2] == p2, 3])
}
}
}
diag(sim_matrix) = max(sim_matrix)
sim_matrix[,1]
tclust_res<- tclust(simmatrix = sim_matrix, convert_dissimilarity_to_similarity = FALSE, threshold = THRESHOLD)
tclust_res
p1 = proteins[1]
p1
presec = df_table[df_table[,1] == p1 | df_table[,2] == p1, ]
presec
df_table[,1] == p1
df_table[,1] == p1 | df_table[,2] == p1
min(presec[presec[,1] == p2, 3], presec[presec[,2] == p2, 3]
)
min(presec[presec[,1] == p2, 3], presec[presec[,2] == 2, 3]
)
presec = df_table[df_table[,1] == p1 | df_table[,2] == p1, ]
presec
SD <- 1
CLUSTER_SIZE <- 50
THRESHOLD = 15
THRESHOLD = 50
table <- read.table("brown.txt", sep = "", skip = 5)
df_table <- as.data.frame(table)
proteins = levels(df_table[,1])
sim_matrix = matrix(0,nrow = length(proteins), ncol = length(proteins))
row.names(sim_matrix) = proteins
colnames(sim_matrix) = proteins
p1 = proteins[x]
for(x in 1:(length(proteins)-1)){
# Select all rows containing p1
p1 = proteins[x]
presec = df_table[df_table[,1] == p1 | df_table[,2] == p1, ]
for(y in (x+1):length(proteins)){
p2 = proteins[y]
# We have to check for both directions p1 -> p2 and p2 <- p1. Rule is, to be more conservative, we take the minimum of both values
if(length(presec[presec[,1] == p2, 3])==0 | length(presec[presec[,2] == p2, 3])==0){
#Allright, one value was missing, we take 0 as fallback (since there is no meaningful minimum)
sim_matrix[x,y] = sim_matrix[y,x] = 0
}else{
#Take the minimum of both directions
sim_matrix[x,y] = sim_matrix[y,x] = min(presec[presec[,1] == p2, 3], presec[presec[,2] == p2, 3])
}
}
}
df_table[,1]
c <- matrix(rexp(20, rate=.1), ncol=5)
c[,1]
c
df_table
?rexp
c
matrix(sample(15,900,T),9)
matrix(sample(15,20,T),9)
matrix(sample(15,20,T),5)
matrix(sample(15,25,T),5)
c <- matrix(sample(15,25,T),5)
c1 <- c[1]
c1
c1 <- c[2]
c1 <- c[1]
c[1]
c[2]
c <- matrix(sample(100,25,T),5)
c[1]
c
c1 <- c[1]
c2 <- c[2]
c2
c[1]
c[2]
c[3]
c[4]
c[5]
pre <- c[c[,1] == c1 | c[,2] == c1,]
pre
c1
c
c1 <- c[2]
c1
pre <- c[c[,1] == c1 | c[,2] == c1,]
pre
pre <- c[c[,1] == c1,]
pre
c[c[,1] == c1,3]
?dist
BLASTdata
data(BLASTdata)
RFLP
RFLPdata
?simPlot
install.packages("MKmisc")
install.packages("robustbase")
install.packages("robustbase")
